package language

import (
	"flag"
	"log"

	"example.com/my-gazelle-plugin/gazelle"
	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
	"github.com/bazelbuild/buildtools/build"
)

// cmakeLang implements the language.Language interface for CMake.
type cmakeLang struct{}

// NewLanguage returns a new instance of the CMake language plugin.
func NewLanguage() language.Language {
	return &cmakeLang{}
}

// Name returns the name of the language. This should be a prefix
// of the kinds of rules generated by the language, e.g., "go" for
// "go_library".
func (l *cmakeLang) Name() string {
	return "cmake"
}

// RegisterFlags registers command-line flags used by the language.
// The syntax of options passed to Gazelle is determined by package flag.
// All flags registered here become directives in BUILD files.
func (l *cmakeLang) RegisterFlags(fs *flag.FlagSet, mode string, c *config.Config) {
	// No flags registered for now.
}

// CheckFlags validates command-line flags and items in config files.
// Call fs.Visit to already-parsed flags.
func (l *cmakeLang) CheckFlags(fs *flag.FlagSet, c *config.Config) error {
	// No flags to check for now.
	return nil
}

// KnownDirectives returns a list of directive keys that this language
// understands. Gazelle will warn about directives that are not recognized.
func (l *cmakeLang) KnownDirectives() []string {
	// Combine directives known by the language itself and by the configurer.
	// This helps Gazelle recognize all valid directives.
	baseDirectives := []string{"gazelle:prefix"} // Directives handled by Gazelle itself or the language directly
	configDirectives := gazelle.NewCMakeConfig().KnownDirectives() // Directives handled by CMakeConfig
	return append(baseDirectives, configDirectives...)
}

// Configure modifies the configuration using directives found in BUILD files.
// Called with directives in root and package directories.
func (l *cmakeLang) Configure(c *config.Config, rel string, f *rule.File) {
	if f == nil {
		return // Not a BUILD file, skip.
	}

	cfg := gazelle.GetCMakeConfig(c) // Assuming gazelle is the package name of config.go

	// Iterate over directives in the BUILD file
	for _, directive := range f.Directives {
		// Check if the directive is one that the language itself handles directly
		// (as opposed to general configuration handled by CMakeConfig.Configure)
		switch directive.Key {
		// Example: Handle a language-specific directive if any
		// case "cmake_custom_lang_setting":
		//    log.Printf("cmakeLang.Configure: Found directive %s = %s", directive.Key, directive.Value)
		//    // Update language-specific state if necessary
		default:
			// If not handled by the language directly, it might be a general config
			// directive already processed by CMakeConfig.Configure via RegisterConfigurer.
			// Or, it could be an unknown directive if not in KnownDirectives() of either.
		}
	}

	// The CMakeConfig.Configure method (registered via config.RegisterConfigurer)
	// will also be called by Gazelle automatically for directives in its KnownDirectives list.
	// So, cfg will be populated by directives like "cmake_executable".
	// You can access cfg.CMakeExecutable here if needed for language-specific logic.
	log.Printf("language.Configure: CMake executable is configured to: %s (in directory %s)", cfg.CMakeExecutable, rel)
}

// Kinds returns a map of Bazel rule kinds supported by this language.
func (l *cmakeLang) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		"cc_library": {
			NonEmptyAttrs:  map[string]bool{"srcs": true, "hdrs": true},
			MergeableAttrs: map[string]bool{"srcs": true, "hdrs": true, "deps": true},
			ResolveAttrs:   map[string]bool{"deps": true},
		},
		"cc_binary": {
			NonEmptyAttrs:  map[string]bool{"srcs": true},
			MergeableAttrs: map[string]bool{"srcs": true, "deps": true},
			ResolveAttrs:   map[string]bool{"deps": true},
		},
		"cc_test": {
			NonEmptyAttrs:  map[string]bool{"srcs": true},
			MergeableAttrs: map[string]bool{"srcs": true, "deps": true},
			ResolveAttrs:   map[string]bool{"deps": true},
			Kind:           rule.TestKind, // Mark this as a test rule
		},
	}
}

// Loads returns .bzl files and symbols they define.
func (l *cmakeLang) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		{
			Name:    "@rules_cc//cc:defs.bzl",
			Symbols: []string{"cc_library", "cc_binary", "cc_test"},
		},
	}
}

// GenerateRules extracts build metadata from source files in a directory.
// GenerateRules is called in each directory where an update is requested
// in resolve or generate mode.
func (l *cmakeLang) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	// Delegate to the GenerateRules function in the gazelle package.
	// Ensure the gazelle package (containing config.go and generate.go) is imported.
	// For example, if your go.mod is `module example.com/my-gazelle-plugin`,
	// and generate.go is in `my-gazelle-plugin/gazelle/`, then
	// import "example.com/my-gazelle-plugin/gazelle"
	return gazelle.GenerateRules(args)
}

// UpdateRules is called to update existing rules in a BUILD file.
// args.Rel is the package name. args.File is the existing BUILD file.
// Note: This will be implemented later.
func (l *cmakeLang) UpdateRules(args language.UpdateArgs) language.UpdateResult {
	return language.UpdateResult{}
}

// Resolve resolves dependencies for rules in the given BUILD file.
// This is called in resolve mode after GenerateRules and UpdateRules have run.
// 'r' is the rule to resolve. 'imports' is a list of imported strings.
// 'from' is the label of the rule 'r'.
func (l *cmakeLang) Resolve(c *config.Config, ix *resolve.RuleIndex, rc *repo.RemoteCache, r *rule.Rule, imports interface{}, from resolve.Label) []resolve.FindResult {
	// Delegate to the ResolveDeps function in the gazelle package.
	// The 'imports' interface{} parameter in language.Resolver is what GenerateRules
	// returns in GenerateResult.Imports. Our current GenerateRules returns nil for Imports.
	// A more complete GenerateRules would parse source files for #include statements
	// and return them as []string in GenerateResult.Imports.
	if r.Kind() != "cc_library" && r.Kind() != "cc_binary" && r.Kind() != "cc_test" {
		return nil // We only resolve for our own rule kinds.
	}
	log.Printf("cmakeLang.Resolve: Called for rule %s %s, imports type: %T", r.Kind(), r.Name(), imports)
	return gazelle.ResolveDeps(c, ix, rc, r, imports, from)
}

// CanCrossResolve indicates whether this language can resolve dependencies
// in rules of another language. For example, if a Go rule depends on a C++ library.
func (l *cmakeLang) CanCrossResolve(other language.Language) bool {
	// For now, let's say CMake can resolve dependencies if the other language is Go,
	// assuming CGo might be involved, or if it's another C++ rule generator.
	// This is a placeholder; real cross-resolution logic is more involved.
	// log.Printf("CanCrossResolve: Checking if cmake can cross-resolve with %s", other.Name())
	// return other.Name() == "go" || other.Name() == "cc" // Example
	return false // Keep it simple for now.
}
