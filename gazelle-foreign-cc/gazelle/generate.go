package gazelle

import (
	"log"
	"path/filepath"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

// GenerateRules analyzes files in a directory and returns a list of rules and imports.
// This is a simplified initial implementation.
func GenerateRules(args language.GenerateArgs) language.GenerateResult {
	res := language.GenerateResult{}
	cfg := GetCMakeConfig(args.Config) // Assuming GetCMakeConfig is in this package or imported

	// Placeholder for CMakeLists.txt parsing logic
	// For now, let's find all .cc, .cpp, .h, .hpp files and generate a cc_library
	// if any are found. A more sophisticated approach would parse CMakeLists.txt.

	var srcs []string
	var hdrs []string
	hasCppFiles := false
	isTestDir := strings.Contains(args.Rel, "test") // Simple heuristic for tests

	for _, f := range args.RegularFiles {
		ext := filepath.Ext(f)
		if ext == ".cc" || ext == ".cpp" || ext == ".cxx" {
			srcs = append(srcs, f)
			hasCppFiles = true
		} else if ext == ".h" || ext == ".hpp" || ext == ".hxx" {
			hdrs = append(hdrs, f)
			// We don't set hasCppFiles for headers only, typically a library needs sources.
		}
	}

	if !hasCppFiles && len(hdrs) > 0 {
		// If only headers, create a cc_library for them (header-only library)
		libName := filepath.Base(args.Rel) + "_hdrs"
		if args.Rel == "" { // Root directory
			libName = cfg.ReadDirective("gazelle:prefix") + "_hdrs" // Requires gazelle:prefix
			if libName == "_hdrs" {
				libName = "root_hdrs" // fallback if no prefix
			}
		}

		r := rule.NewRule("cc_library", libName)
		if len(hdrs) > 0 {
			r.SetAttr("hdrs", hdrs)
		}
		// Potentially set other attributes like "includes" if needed
		// r.SetAttr("includes", []string{"."}) // Expose headers in the current directory
		res.Gen = append(res.Gen, r)
		res.Empty = append(res.Empty, rule.NewRule("cc_library", libName)) // For cleaning up old rules
		log.Printf("Generated header-only cc_library %s in %s", libName, args.Rel)

	} else if hasCppFiles {
		// Determine rule kind and name
		var ruleKind string
		var ruleName string

		// Simple naming: use directory name.
		// If args.Rel is empty, it's the root package.
		if args.Rel == "" {
			// Try to get prefix from config, otherwise use a default name like "main_lib" or "main_bin"
			prefix := cfg.ReadDirective("gazelle:prefix") // Assuming ReadDirective helper or direct access
			if prefix == "" {
				prefix = "default_pkg" // Fallback if no prefix
			}
			ruleName = prefix
		} else {
			ruleName = filepath.Base(args.Rel)
		}


		if isTestDir {
			ruleKind = "cc_test"
			ruleName = ruleName + "_test"
		} else if strings.Contains(strings.Join(srcs, " "), "main(") { // Very basic check for a binary
			ruleKind = "cc_binary"
			ruleName = ruleName + "_bin"
		} else {
			ruleKind = "cc_library"
			ruleName = ruleName + "_lib"
		}

		r := rule.NewRule(ruleKind, ruleName)
		if len(srcs) > 0 {
			r.SetAttr("srcs", srcs)
		}
		if len(hdrs) > 0 {
			r.SetAttr("hdrs", hdrs)
		}

		// TODO: Add dependency detection logic here based on includes or CMakeLists.txt parsing
		// For now, imports are empty.
		// res.Imports = append(res.Imports, /* ... */)

		res.Gen = append(res.Gen, r)
		// For "empty" rules, provide a rule with the same kind and name.
		// This helps Gazelle determine if an existing rule with this name/kind,
		// if it has no attributes Gazelle considers significant (like srcs/hdrs here),
		// should be removed or kept.
		res.Empty = append(res.Empty, rule.NewRule(ruleKind, ruleName))
		log.Printf("Generated %s %s in %s with srcs: %v, hdrs: %v", ruleKind, ruleName, args.Rel, srcs, hdrs)
	} else {
		// No C++ source or header files found.
		// If we were parsing CMakeLists.txt, we might still generate rules.
		log.Printf("No C++ source or header files found in %s. No rules generated by simple file scan.", args.Rel)
	}

	// If there was a CMakeLists.txt, we would parse it here.
	// For example:
	// cmakeFilePath := filepath.Join(args.Dir, "CMakeLists.txt")
	// if _, err := os.Stat(cmakeFilePath); err == nil {
	// parseCMakeLists(cmakeFilePath, &res, cfg)
	// }

	return res
}

// TODO: Implement a more sophisticated CMakeLists.txt parser
// func parseCMakeLists(path string, res *language.GenerateResult, cfg *CMakeConfig) {
//    log.Printf("Parsing CMakeLists.txt at %s (not implemented yet)", path)
//    // This function would:
//    // 1. Read and parse the CMakeLists.txt file.
//    // 2. Identify targets (add_library, add_executable, add_custom_target).
//    // 3. Extract sources, headers, dependencies, and other relevant information.
//    // 4. Create rule.NewRule objects and add them to res.Gen.
//    // 5. Populate res.Imports with dependencies found.
// }
