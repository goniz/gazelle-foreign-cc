package language

import (
	"encoding/json"
	"testing"
)

func TestCMakeFileAPIErrorHandling(t *testing.T) {
	// Test that verifies the improved error handling and JSON parsing robustness
	// This simulates the kind of JSON that might be generated by complex projects like libzmq
	
	// Test 1: Verify that malformed JSON is handled gracefully
	malformedJSON := `{
		"id": "libzmq::@abc123",
		"name": "libzmq",
		"type": "STATIC_LIBRARY",
		"compileGroups": [
			{
				"language": "CXX",
				"includes": [
					{"path": "/usr/include", "isSystem": true, "extraField": "unexpected"},
					{"path": "include", "newField": {"nested": "object"}}
				],
				"unknownArray": [1, 2, 3],
				"anotherField": "value"
			}
		],
		"unknownTopLevelField": {"complex": "object"},
		"additionalData": ["array", "of", "strings"]
	}`
	
	var target Target
	err := json.Unmarshal([]byte(malformedJSON), &target)
	if err != nil {
		t.Errorf("JSON parsing should be robust and handle unknown fields, but got error: %v", err)
	}
	
	// Test 2: Verify that extractIncludeDirectories handles various edge cases
	testCases := []struct {
		name         string
		compileGroups string
		expectIncludes int
	}{
		{
			name: "normal_includes",
			compileGroups: `[{
				"language": "CXX",
				"includes": [
					{"path": "include", "isSystem": false},
					{"path": "/usr/include", "isSystem": true},
					{"path": "src", "isSystem": false}
				]
			}]`,
			expectIncludes: 2, // Only non-system includes
		},
		{
			name: "empty_includes",
			compileGroups: `[{
				"language": "CXX",
				"includes": []
			}]`,
			expectIncludes: 0,
		},
		{
			name: "null_includes",
			compileGroups: `[{
				"language": "CXX"
			}]`,
			expectIncludes: 0,
		},
		{
			name: "malformed_includes",
			compileGroups: `[{
				"language": "CXX",
				"includes": "not an array"
			}]`,
			expectIncludes: 0, // Should handle gracefully
		},
	}
	
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			target := &Target{
				Name: "test",
				ID:   "test::@123",
				Type: "STATIC_LIBRARY",
				CompileGroups: json.RawMessage(tc.compileGroups),
			}
			
			includes := extractIncludeDirectories(target, "/test")
			if len(includes) != tc.expectIncludes {
				t.Errorf("Expected %d includes, got %d for case %s", tc.expectIncludes, len(includes), tc.name)
			}
		})
	}
}

func TestBackwardsCompatibility(t *testing.T) {
	// Ensure that the changes don't break parsing of existing valid JSON
	// This represents the JSON structure we know works from our simple test cases
	
	validJSON := `{
		"archive" : {},
		"artifacts" : [{"path" : "libmy_lib.a"}],
		"backtrace" : 1,
		"compileGroups" : [{
			"language" : "CXX",
			"sourceIndexes" : [0]
		}],
		"id" : "my_lib::@6890427a1f51a3e7e1df",
		"name" : "my_lib",
		"nameOnDisk" : "libmy_lib.a",
		"paths" : {"build" : ".", "source" : "."},
		"sources" : [{
			"backtrace" : 1,
			"compileGroupIndex" : 0,
			"path" : "lib.cc",
			"sourceGroupIndex" : 0
		}],
		"type" : "STATIC_LIBRARY"
	}`
	
	var target Target
	err := json.Unmarshal([]byte(validJSON), &target)
	if err != nil {
		t.Errorf("Valid JSON should parse successfully, but got error: %v", err)
	}
	
	if target.Name != "my_lib" {
		t.Errorf("Expected name 'my_lib', got '%s'", target.Name)
	}
	if target.Type != "STATIC_LIBRARY" {
		t.Errorf("Expected type 'STATIC_LIBRARY', got '%s'", target.Type)
	}
	if target.Backtrace != 1 {
		t.Errorf("Expected backtrace 1, got %d", target.Backtrace)
	}
}