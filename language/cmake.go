package language

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
	"github.com/bazelbuild/rules_go/go/tools/bazel"
	"github.com/goniz/gazelle-foreign-cc/common"
)

// cmakeLang implements the language.Language interface for CMake.
type cmakeLang struct{}

// NewLanguage returns a new instance of the CMake language plugin.
func NewLanguage() language.Language {
	return &cmakeLang{}
}

// Name returns the name of the language. This should be a prefix
// of the kinds of rules generated by the language, e.g., "go" for
// "go_library".
func (l *cmakeLang) Name() string {
	return "cmake"
}

// Embeds returns a list of labels that this rule embeds.
func (l *cmakeLang) Embeds(r *rule.Rule, from label.Label) []label.Label {
	return nil
}

// RegisterFlags registers command-line flags used by the language.
// The syntax of options passed to Gazelle is determined by package flag.
// All flags registered here become directives in BUILD files.
func (l *cmakeLang) RegisterFlags(fs *flag.FlagSet, mode string, c *config.Config) {
	// No flags registered for now.
}

// CheckFlags validates command-line flags and items in config files.
// Call fs.Visit to already-parsed flags.
func (l *cmakeLang) CheckFlags(fs *flag.FlagSet, c *config.Config) error {
	// No flags to check for now.
	return nil
}

// KnownDirectives returns a list of directive keys that this language
// understands. Gazelle will warn about directives that are not recognized.
func (l *cmakeLang) KnownDirectives() []string {
	// Combine directives known by the language itself and by the configurer.
	// This helps Gazelle recognize all valid directives.
	baseDirectives := []string{"gazelle:prefix"}                  // Directives handled by Gazelle itself or the language directly
	configDirectives := common.NewCMakeConfig().KnownDirectives() // Directives handled by CMakeConfig
	return append(baseDirectives, configDirectives...)
}

// Configure modifies the configuration using directives found in BUILD files.
// Called with directives in root and package directories.
func (l *cmakeLang) Configure(c *config.Config, rel string, f *rule.File) {
	if f == nil {
		return // Not a BUILD file, skip.
	}

	cfg := common.GetCMakeConfig(c)

	// Let the CMakeConfig handle its own directives
	cfg.Configure(c, rel, f)

	// Iterate over directives in the BUILD file for language-specific handling
	for _, directive := range f.Directives {
		// Check if the directive is one that the language itself handles directly
		// (as opposed to general configuration handled by CMakeConfig.Configure)
		switch directive.Key {
		// Example: Handle a language-specific directive if any
		// case "cmake_custom_lang_setting":
		//    log.Printf("cmakeLang.Configure: Found directive %s = %s", directive.Key, directive.Value)
		//    // Update language-specific state if necessary
		default:
			// If not handled by the language directly, it might be a general config
			// directive already processed by CMakeConfig.Configure.
		}
	}

	log.Printf("language.Configure: CMake executable is configured to: %s (in directory %s)", cfg.CMakeExecutable, rel)
}

// Kinds returns a map of Bazel rule kinds supported by this language.
func (l *cmakeLang) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		"cc_library": {
			NonEmptyAttrs:  map[string]bool{"srcs": true, "hdrs": true},
			MergeableAttrs: map[string]bool{"srcs": true, "hdrs": true, "deps": true},
			ResolveAttrs:   map[string]bool{"deps": true},
		},
		"cc_binary": {
			NonEmptyAttrs:  map[string]bool{"srcs": true},
			MergeableAttrs: map[string]bool{"srcs": true, "deps": true},
			ResolveAttrs:   map[string]bool{"deps": true},
		},
		"cc_test": {
			NonEmptyAttrs:  map[string]bool{"srcs": true},
			MergeableAttrs: map[string]bool{"srcs": true, "deps": true},
			ResolveAttrs:   map[string]bool{"deps": true},
		},
		"cmake_configure_file": {
			NonEmptyAttrs:  map[string]bool{"src": true, "out": true},
			MergeableAttrs: map[string]bool{"defines": true},
			ResolveAttrs:   map[string]bool{},
		},
		"cmake_include_directories": {
			NonEmptyAttrs:  map[string]bool{"srcs": true},
			MergeableAttrs: map[string]bool{"includes": true, "additional_hdrs": true, "defines": true},
			ResolveAttrs:   map[string]bool{},
		},
	}
}

// Loads returns .bzl files and symbols they define.
func (l *cmakeLang) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		{
			Name:    "@rules_cc//cc:defs.bzl",
			Symbols: []string{"cc_library", "cc_binary", "cc_test"},
		},
		{
			Name:    "@gazelle-foreign-cc//rules:cmake_configure_file.bzl",
			Symbols: []string{"cmake_configure_file"},
		},
		{
			Name:    "@gazelle-foreign-cc//rules:cmake_include_directories.bzl",
			Symbols: []string{"cmake_include_directories"},
		},
	}
}

// GenerateRules extracts build metadata from source files in a directory.
// GenerateRules is called in each directory where an update is requested
// in resolve or generate mode.
func (l *cmakeLang) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	cfg := common.GetCMakeConfig(args.Config)

	// Check for cmake_source directive and collect cmake_define directives from the current BUILD file
	var cmakeSource string
	packageDefines := make(map[string]string)
	
	if args.File != nil {
		for _, directive := range args.File.Directives {
			if directive.Key == "cmake_source" {
				cmakeSource = directive.Value
				log.Printf("Found cmake_source directive: %s in package %s", cmakeSource, args.Rel)
			} else if directive.Key == "cmake_define" {
				// Parse cmake_define directive in format "KEY VALUE"
				parts := strings.Fields(directive.Value)
				if len(parts) != 2 {
					log.Printf("Invalid cmake_define directive format '%s' in %s. Expected format: 'KEY VALUE'", directive.Value, args.Rel)
					continue
				}
				key, value := parts[0], parts[1]
				packageDefines[key] = value
				log.Printf("Found cmake_define directive %s=%s in package %s", key, value, args.Rel)
			}
		}
	}

	// If we have a cmake_source directive pointing to external sources, process that
	if cmakeSource != "" {
		log.Printf("cmakeLang.GenerateRules: Processing cmake_source directive %s for package %s with %d defines", cmakeSource, args.Rel, len(packageDefines))
		return l.generateRulesFromExternalSource(args, cmakeSource, packageDefines)
	}

	// Otherwise, look for local CMakeLists.txt
	cmakeFilePath := filepath.Join(args.Dir, "CMakeLists.txt")

	if _, err := os.Stat(cmakeFilePath); os.IsNotExist(err) {
		log.Printf("No CMakeLists.txt found in %s (%s). Skipping directory.", args.Rel, cmakeFilePath)
		return language.GenerateResult{}
	}

	log.Printf("cmakeLang.GenerateRules: Called for package %s", args.Rel)

	// Try to use CMake File API first
	buildDir := filepath.Join(args.Dir, ".cmake-build")
	api := NewCMakeFileAPI(args.Dir, buildDir, cfg.CMakeExecutable, packageDefines)

	cmakeTargets, err := api.GenerateFromAPI(args.Rel)
	if err != nil {
		log.Printf("CMake File API failed for %s: %v. Falling back to regex parsing.", args.Rel, err)
		// Fallback to regex-based parsing using the existing function from gazelle package
		return common.GenerateRulesWithDefines(args, packageDefines)
	}

	return l.generateRulesFromTargets(args, cmakeTargets, packageDefines)
}

// generateRulesFromExternalSource handles the cmake_source directive pointing to external sources
func (l *cmakeLang) generateRulesFromExternalSource(args language.GenerateArgs, sourceLabel string, packageDefines map[string]string) language.GenerateResult {
	log.Printf("generateRulesFromExternalSource: Processing external source %s", sourceLabel)

	if !strings.HasPrefix(sourceLabel, "@") {
		log.Printf("Invalid external source label format: %s. Expected format: @repo", sourceLabel)
		return language.GenerateResult{}
	}

	// For cmake_source directive, expect simple format: @repo_name
	repoName := sourceLabel[1:] // Remove @ prefix
	if repoName == "" {
		log.Printf("Empty repository name in cmake_source directive: %s", sourceLabel)
		return language.GenerateResult{}
	}
	if strings.Contains(repoName, "/") {
		log.Printf("Invalid cmake_source format: %s. Expected simple format: @repo", sourceLabel)
		return language.GenerateResult{}
	}

	// For this implementation, we'll look for the external repository in common locations
	// This is a simplified approach - a full implementation would integrate with Bazel's
	// repository resolution system
	externalRepoPath := l.findExternalRepo(repoName, args)
	if externalRepoPath == "" {
		log.Printf("Could not find external repository %s for label %s", repoName, sourceLabel)
		return language.GenerateResult{}
	}

	log.Printf("Found external repository %s at %s", repoName, externalRepoPath)

	// Look for CMakeLists.txt in the external repository
	cmakeFilePath := filepath.Join(externalRepoPath, "CMakeLists.txt")
	if _, err := os.Stat(cmakeFilePath); os.IsNotExist(err) {
		log.Printf("No CMakeLists.txt found in external repository %s at %s", repoName, cmakeFilePath)
		return language.GenerateResult{}
	}

	log.Printf("Found CMakeLists.txt in external repository at: %s", cmakeFilePath)

	// Process the external CMake project
	cfg := common.GetCMakeConfig(args.Config)
	buildDir := filepath.Join(externalRepoPath, ".cmake-build")
	api := NewCMakeFileAPI(externalRepoPath, buildDir, cfg.CMakeExecutable, packageDefines)

	cmakeTargets, err := api.GenerateFromAPI(args.Rel)
	if err != nil {
		log.Printf("CMake File API failed for external source %s: %v. Falling back to regex parsing.", sourceLabel, err)
		// Create a modified args for the external directory
		externalArgs := args
		externalArgs.Dir = externalRepoPath
		return common.GenerateRulesWithDefines(externalArgs, packageDefines, repoName)
	}

	log.Printf("Successfully parsed %d CMake targets from external repository %s", len(cmakeTargets), repoName)

	// Create modified args that point to the external repository directory
	// This is needed so that source file existence checks work correctly
	externalArgs := args
	externalArgs.Dir = externalRepoPath
	return l.generateRulesFromTargetsWithRepoAndAPI(externalArgs, cmakeTargets, repoName, api, packageDefines)
}

// findExternalRepo attempts to locate an external repository
// This uses the simplified runfiles-based approach instead of complex guessing logic
func (l *cmakeLang) findExternalRepo(repoName string, args language.GenerateArgs) string {
	// Use runfiles-based discovery (reliable when repo is provided as data)
	if repoPath := l.findRepoViaRunfiles(repoName); repoPath != "" {
		return repoPath
	}

	log.Printf("Could not find external repository '%s' - ensure it's provided as data to the gazelle rule (e.g., data = [\"@%s//:srcs\"])", repoName, repoName)
	return ""
}

// findRepoViaRunfiles uses Bazel runfiles to locate external repositories
// This implementation uses a hybrid approach: first try the runfiles API with
// common patterns, then fall back to direct filesystem access for patterns
// that the API might not handle correctly (like bzlmod repository names).
func (l *cmakeLang) findRepoViaRunfiles(repoName string) string {
	log.Printf("Attempting to find repository '%s' via runfiles", repoName)

	// First, try the runfiles API approach with different patterns
	possibleRunfilePaths := []string{
		repoName,               // Direct repository name
		"_main/" + repoName,    // Main workspace relative path
		"@" + repoName,         // With @ prefix
		"external/" + repoName, // Under external directory
		"+" + repoName,         // Simple bzlmod pattern
	}

	for _, path := range possibleRunfilePaths {
		if repoPath, err := bazel.Runfile(path); err == nil {
			if stat, err := os.Stat(repoPath); err == nil && stat.IsDir() {
				log.Printf("Found repository via runfiles API at: %s", repoPath)
				return repoPath
			}
		}
	}

	// If the runfiles API didn't work, try direct runfiles directory access
	// This is necessary for bzlmod repositories which use special naming patterns
	// like "+_repo_rules+reponame" that the runfiles API doesn't handle well
	if runfilesDir := os.Getenv("RUNFILES_DIR"); runfilesDir != "" {
		directPaths := []string{
			filepath.Join(runfilesDir, "+_repo_rules+"+repoName), // Bzlmod repo rules pattern
			filepath.Join(runfilesDir, "+"+repoName),             // Simple bzlmod pattern
			filepath.Join(runfilesDir, repoName),                 // Direct name
		}

		for _, dirPath := range directPaths {
			if stat, err := os.Stat(dirPath); err == nil && stat.IsDir() {
				log.Printf("Found repository via direct runfiles path at: %s", dirPath)
				return dirPath
			}
		}
	}

	log.Printf("Could not find repository '%s' via runfiles", repoName)
	return ""
}

// generateRulesFromTargets converts CMakeTarget objects to Bazel rules
func (l *cmakeLang) generateRulesFromTargets(args language.GenerateArgs, cmakeTargets []*common.CMakeTarget, packageDefines map[string]string) language.GenerateResult {
	// Generate rules from CMake targets (this function handles both cc_* and cmake_configure_file rules)
	result := l.generateRulesFromTargetsWithRepoAndAPI(args, cmakeTargets, "", nil, packageDefines)

	// The configure_file logic is handled in generateRulesFromTargetsWithRepoAndAPI
	// No additional processing needed here

	return result
}

// Helper function to check if file exists in regular files
func fileExistsInRegularFiles(filename string, regularFiles []string) bool {
	for _, file := range regularFiles {
		if file == filename {
			return true
		}
	}
	return false
}

// generateRulesFromTargetsWithRepoAndAPI converts CMakeTarget objects to Bazel rules, with optional external repository context and CMakeFileAPI
func (l *cmakeLang) generateRulesFromTargetsWithRepoAndAPI(args language.GenerateArgs, cmakeTargets []*common.CMakeTarget, externalRepo string, api *CMakeFileAPI, packageDefines map[string]string) language.GenerateResult {
	res := language.GenerateResult{}

	// Additionally, detect configure_file commands using CMake File API approach
	var configureFiles []*common.CMakeConfigureFile
	if api != nil {
		// Use the provided API instance (for external repositories)
		var err error
		configureFiles, err = api.DetectConfigureFileCommands()
		if err != nil {
			log.Printf("CMake File API configure_file detection failed for %s: %v", args.Rel, err)
			configureFiles = []*common.CMakeConfigureFile{}
		}
	} else {
		// Create a new API instance for local directories
		cfg := common.GetCMakeConfig(args.Config)
		buildDir := filepath.Join(args.Dir, ".cmake-build")
		localAPI := NewCMakeFileAPI(args.Dir, buildDir, cfg.CMakeExecutable, packageDefines)
		var err error
		configureFiles, err = localAPI.DetectConfigureFileCommands()
		if err != nil {
			log.Printf("CMake File API configure_file detection failed for %s: %v", args.Rel, err)
			configureFiles = []*common.CMakeConfigureFile{}
		}
	}

	// Discover headers that could match configure_file outputs
	discoverConfigureFileHeaders(cmakeTargets, configureFiles, args.Dir)

	// First, collect all generated files that are actually referenced by CMake targets
	referencedGeneratedFiles := make(map[string]*common.CMakeConfigureFile)

	// Check which configure_file outputs are actually referenced by CMake targets
	for _, cmTarget := range cmakeTargets {
		for _, header := range cmTarget.Headers {
			// Check if this header matches any configure_file output
			for _, configFile := range configureFiles {
				if matchesConfigureFileOutput(header, configFile.OutputFile) {
					referencedGeneratedFiles[configFile.OutputFile] = configFile
					log.Printf("Target %s references configure_file output %s", cmTarget.Name, configFile.OutputFile)
				}
			}
		}
	}

	// Create a mapping of generated file paths to target names for dependency resolution
	generatedFileMap := make(map[string]string)

	// Generate cmake_configure_file rules only for files that are actually referenced
	for _, configFile := range referencedGeneratedFiles {
		// For external repos, we need to check if the input file exists in the external repo
		var inputFileRef string
		if externalRepo != "" {
			// Check if the input file exists in the external repository
			inputFilePath := filepath.Join(args.Dir, configFile.InputFile)
			if _, err := os.Stat(inputFilePath); err == nil {
				// Clean up the input file path for Bazel label
				cleanInputFile := strings.TrimPrefix(configFile.InputFile, "./")
				inputFileRef = "@" + externalRepo + "//:" + cleanInputFile
			} else {
				log.Printf("Input file %s for configure_file not found in external repository %s, skipping.", configFile.InputFile, externalRepo)
				continue
			}
		} else {
			// Check if the input file exists in the current directory
			if !fileExistsInRegularFiles(configFile.InputFile, args.RegularFiles) {
				log.Printf("Input file %s for configure_file not found in current directory, skipping.", configFile.InputFile)
				continue
			}
			inputFileRef = configFile.InputFile
		}

		r := rule.NewRule("cmake_configure_file", configFile.Name)
		// Use the full output path provided by CMake so that generated
		// files appear in the expected directory structure (e.g.
		// `.cmake-build/foo.h`).  This ensures include paths reported by
		// CMake match the Bazel output location.
		outputPath := configFile.OutputFile
		if !strings.HasPrefix(outputPath, ".cmake-build/") {
			outputPath = ".cmake-build/" + filepath.Base(configFile.OutputFile)
		}
		r.SetAttr("out", outputPath)

		// Bazel's rule implementation copies the file from the CMake
		// build directory. The path inside that build directory is just
		// the basename of the output file.
		r.SetAttr("generated_file_path", filepath.Base(configFile.OutputFile))

		// Set cmake_binary to reference the examples cmake target for examples directory
		r.SetAttr("cmake_binary", "//:cmake")

		// Set cmake_source_dir to current directory (where CMakeLists.txt is)
		r.SetAttr("cmake_source_dir", ".")

		// Include CMakeLists.txt and the input template file as sources
		var sourceFiles []string
		if externalRepo != "" {
			sourceFiles = []string{"@" + externalRepo + "//:srcs"}
		} else {
			sourceFiles = []string{"CMakeLists.txt"}
			if configFile.InputFile != "" && configFile.InputFile != "CMakeLists.txt" {
				sourceFiles = append(sourceFiles, configFile.InputFile)
			}
		}
		r.SetAttr("cmake_source_files", sourceFiles)

		// Always set defines attribute (even if empty for backward compatibility with tests)
		r.SetAttr("defines", configFile.Variables)

		// Store the output file name for reference by other rules
		r.SetPrivateAttr("cmake_configure_output", outputPath)

		res.Gen = append(res.Gen, r)

		// Store mapping from generated file path to target name for dependency resolution
		if externalRepo != "" {
			// For external repos, map the generated file path
			generatedFileMap["@"+externalRepo+"//:"+outputPath] = ":" + configFile.Name
			// Also map the base filename pattern that CMake might report
			generatedFileMap["@"+externalRepo+"//:"+filepath.Base(configFile.OutputFile)] = ":" + configFile.Name
		} else {
			generatedFileMap[outputPath] = ":" + configFile.Name
			// Also map the base filename pattern that CMake might report
			generatedFileMap[filepath.Base(configFile.OutputFile)] = ":" + configFile.Name
		}

		log.Printf("Generated cmake_configure_file %s in %s: %s -> %s with defines: %v",
			r.Name(), args.Rel, inputFileRef, outputPath, configFile.Variables)
	}

	// Create a map of target names for quick lookup to identify local targets
	targetNames := make(map[string]bool)
	for _, cmTarget := range cmakeTargets {
		targetNames[cmTarget.Name] = true
	}

	// Collect unique include directory sets and generate cmake_include_directories targets
	type includeSet struct {
		includes []string
		targets  []string // targets that use this include set
	}
	
	includeSetMap := make(map[string]*includeSet) // key is stringified include set
	includeTargetMap := make(map[string]string)    // maps target name to include target name
	
	// Helper function to normalize includes for consistent comparison
	normalizeIncludes := func(dirs []string, hasGeneratedDeps bool, isExternal bool) []string {
		var normalized []string
		
		// For external repositories, don't add .cmake-build to includes since 
		// cmake_configure_file rules provide the correct include path through CcInfo
		// For local repositories, add .cmake-build directory to includes if there are generated deps
		if hasGeneratedDeps && !isExternal {
			normalized = append(normalized, ".cmake-build")
		}
		
		if len(dirs) > 0 {
			if isExternal {
				// For external repositories, add repository-prefixed paths
				// for CMake-reported include directories, but exclude .cmake-build
				// since generated files are handled by cmake_configure_file dependencies
				for _, dir := range dirs {
					if !filepath.IsAbs(dir) && !strings.HasPrefix(dir, "..") && dir != ".cmake-build" && !strings.HasPrefix(dir, ".cmake-build/") {
						normalized = append(normalized, dir) // Don't prefix here, will be handled in cmake_include_directories
					}
				}
			} else {
				// For local repositories, use includes as before
				for _, dir := range dirs {
					// Only include relative paths that don't go outside the project
					if !filepath.IsAbs(dir) && !strings.HasPrefix(dir, "..") {
						normalized = append(normalized, dir)
					}
				}
			}
		}
		
		return normalized
	}
	
	// Collect unique include sets by examining each target
	for _, cmTarget := range cmakeTargets {
		// Check if this target has generated dependencies
		hasGeneratedDeps := false
		for _, header := range cmTarget.Headers {
			var headerRef string
			if externalRepo != "" {
				headerRef = "@" + externalRepo + "//:" + header
			} else {
				headerRef = header
			}
			if _, isGenerated := generatedFileMap[headerRef]; isGenerated {
				hasGeneratedDeps = true
				break
			}
		}
		
		normalizedIncludes := normalizeIncludes(cmTarget.IncludeDirectories, hasGeneratedDeps, externalRepo != "")
		
		// Only create include targets if there are actual includes
		if len(normalizedIncludes) > 0 {
			includeKey := strings.Join(normalizedIncludes, ",")
			
			if set, exists := includeSetMap[includeKey]; exists {
				// Add this target to the existing include set
				set.targets = append(set.targets, cmTarget.Name)
			} else {
				// Create new include set
				includeSetMap[includeKey] = &includeSet{
					includes: normalizedIncludes,
					targets:  []string{cmTarget.Name},
				}
			}
		}
	}
	
	// Generate cmake_include_directories targets
	for i, set := range includeSetMap {
		var includeName string
		if externalRepo != "" {
			// For external repositories: use repo name + "_includes"
			if len(includeSetMap) == 1 {
				includeName = externalRepo + "_includes"
			} else {
				// Multiple include sets, add suffix
				includeName = fmt.Sprintf("%s_includes_%d", externalRepo, len(res.Gen)+1)
			}
		} else {
			// For local projects: use directory name + "_includes"
			// Get directory name from args.Rel or use "includes" as fallback
			dirName := filepath.Base(args.Rel)
			if dirName == "" || dirName == "." {
				dirName = "project"
			}
			if len(includeSetMap) == 1 {
				includeName = dirName + "_includes"
			} else {
				// Multiple include sets, add suffix
				includeName = fmt.Sprintf("%s_includes_%d", dirName, len(res.Gen)+1)
			}
		}
		
		r := rule.NewRule("cmake_include_directories", includeName)
		
		// Set srcs attribute
		if externalRepo != "" {
			r.SetAttr("srcs", "@"+externalRepo+"//:srcs")
		} else {
			// For local projects, we need to create a filegroup or reference appropriate sources
			// For now, let's use a glob pattern that matches typical source structures
			r.SetAttr("srcs", "glob([\"**/*\"])")
		}
		
		// Set includes attribute
		r.SetAttr("includes", set.includes)
		
		res.Gen = append(res.Gen, r)
		
		// Map all targets in this set to this include target
		for _, targetName := range set.targets {
			includeTargetMap[targetName] = ":" + includeName
		}
		
		log.Printf("Generated cmake_include_directories %s with includes: %v for targets: %v", 
			includeName, set.includes, set.targets)
		
		// Avoid unused variable error
		_ = i
	}

	for _, cmTarget := range cmakeTargets {
		var r *rule.Rule
		if cmTarget.Type == "library" {
			r = rule.NewRule("cc_library", cmTarget.Name)
		} else if cmTarget.Type == "executable" {
			r = rule.NewRule("cc_binary", cmTarget.Name)
		} else {
			log.Printf("Unknown target type for %s: %s", cmTarget.Name, cmTarget.Type)
			continue
		}

		// Filter sources/headers and generate appropriate labels
		var finalSrcs, finalHdrs []string
		for _, s := range cmTarget.Sources {
			if l.fileExistsInDir(s, args.Dir) {
				if externalRepo != "" {
					// For external repositories, generate labels that reference the external repo
					finalSrcs = append(finalSrcs, "@"+externalRepo+"//:"+s)
				} else {
					finalSrcs = append(finalSrcs, s)
				}
			} else {
				log.Printf("Source file %s for target %s not found in current directory, skipping.", s, cmTarget.Name)
			}
		}

		// Track dependencies on cmake_configure_file targets
		var generatedDeps []string

		for _, h := range cmTarget.Headers {
			// Check if this header is a generated file
			var headerRef string
			if externalRepo != "" {
				headerRef = "@" + externalRepo + "//:" + h
			} else {
				headerRef = h
			}

			// Check if this header is generated by a cmake_configure_file rule
			if targetName, isGenerated := generatedFileMap[headerRef]; isGenerated {
				// Reference the generated file via its target label as a dependency
				generatedDeps = append(generatedDeps, targetName)
				log.Printf("Target %s includes generated header %s via target %s", cmTarget.Name, h, targetName)
			} else if l.fileExistsInDir(h, args.Dir) {
				if externalRepo != "" {
					// For external repositories, generate labels that reference the external repo
					finalHdrs = append(finalHdrs, "@"+externalRepo+"//:"+h)
				} else {
					finalHdrs = append(finalHdrs, h)
				}
			} else {
				log.Printf("Header file %s for target %s not found in current directory, skipping.", h, cmTarget.Name)
			}
		}

		if len(finalSrcs) > 0 {
			r.SetAttr("srcs", finalSrcs)
		}
		// Only set hdrs for cc_library targets, not cc_binary
		if len(finalHdrs) > 0 && cmTarget.Type == "library" {
			r.SetAttr("hdrs", finalHdrs)
		}

		// Generate deps attribute for locally linked libraries, cmake_configure_file targets, and include targets
		var deps []string
		for _, linkedLib := range cmTarget.LinkedLibraries {
			// Check if the linked library matches another target in this directory
			if targetNames[linkedLib] {
				// For local targets, use local label syntax
				deps = append(deps, ":"+linkedLib)
			}
		}
		// Add cmake_configure_file targets as dependencies
		deps = append(deps, generatedDeps...)
		
		// Add cmake_include_directories target as dependency if this target has includes
		if includeTarget, hasIncludes := includeTargetMap[cmTarget.Name]; hasIncludes {
			deps = append(deps, includeTarget)
		}
		
		if len(deps) > 0 {
			r.SetAttr("deps", deps)
		}

		// Store linked libraries for dependency resolution
		if len(cmTarget.LinkedLibraries) > 0 {
			r.SetPrivateAttr("cmake_linked_libraries", cmTarget.LinkedLibraries)
		}
		if len(cmTarget.IncludeDirectories) > 0 {
			r.SetPrivateAttr("cmake_include_directories", cmTarget.IncludeDirectories)
		}

		if r.Attr("srcs") != nil || r.Attr("hdrs") != nil {
			res.Gen = append(res.Gen, r)
			// Don't add empty rules for now to test if this fixes the deps issue
			// res.Empty = append(res.Empty, rule.NewRule(r.Kind(), r.Name()))
			log.Printf("Generated %s %s in %s with srcs: %v, hdrs: %v, includes: %v, links: %v",
				r.Kind(), r.Name(), args.Rel, finalSrcs, finalHdrs, cmTarget.IncludeDirectories, cmTarget.LinkedLibraries)
		} else {
			log.Printf("Skipping rule for target %s as no valid sources/headers were found in the current directory.", cmTarget.Name)
		}
	}

	if len(res.Gen) > 0 && len(res.Imports) == 0 {
		res.Imports = make([]interface{}, len(res.Gen))
	}

	return res
}

// fileExistsInDir checks if a file exists in the given directory
func (l *cmakeLang) fileExistsInDir(filename, dir string) bool {
	fullPath := filepath.Join(dir, filename)
	_, err := os.Stat(fullPath)
	return err == nil
}

// UpdateRules is called to update existing rules in a BUILD file.
// args.Rel is the package name. args.File is the existing BUILD file.
// This function can be used to modify or delete existing rules that
// this language extension manages.
func (l *cmakeLang) UpdateRules(args language.GenerateArgs) language.GenerateResult {
	log.Printf("cmakeLang.UpdateRules: Called for package %s", args.Rel)
	cfg := common.GetCMakeConfig(args.Config)
	_ = cfg // Use cfg if needed for update logic based on configuration

	// In a more sophisticated plugin, you might iterate over args.File.Rules
	// to find rules previously generated by this plugin and update or delete them
	// based on changes in the source or CMakeLists.txt.

	// For now, we return an empty result, meaning Gazelle will rely on the rules
	// returned by GenerateRules (and its "Empty" rules for pruning) to determine
	// the final state of the BUILD file.
	return language.GenerateResult{}
}

// Resolve resolves dependencies for rules in the given BUILD file.
// This is called in resolve mode after GenerateRules and UpdateRules have run.
// 'r' is the rule to resolve. 'imports' is a list of imported strings.
// 'from' is the label of the rule 'r'.
func (l *cmakeLang) Resolve(c *config.Config, ix *resolve.RuleIndex, rc *repo.RemoteCache, r *rule.Rule, imports interface{}, from label.Label) {
	// Delegate to the ResolveDeps function in the gazelle package.
	// The 'imports' interface{} parameter in language.Resolver is what GenerateRules
	// returns in GenerateResult.Imports. Our current GenerateRules returns nil for Imports.
	// A more complete GenerateRules would parse source files for #include statements
	// and return them as []string in GenerateResult.Imports.
	if r.Kind() != "cc_library" && r.Kind() != "cc_binary" && r.Kind() != "cc_test" {
		return // We only resolve for our own rule kinds.
	}
	log.Printf("cmakeLang.Resolve: Called for rule %s %s, imports type: %T", r.Kind(), r.Name(), imports)
	// For now, this is a no-op - this is a basic stub
	// In a real implementation, this would resolve dependencies based on #include statements
}

// CanCrossResolve indicates whether this language can resolve dependencies
// in rules of another language. For example, if a Go rule depends on a C++ library.
func (l *cmakeLang) CanCrossResolve(other language.Language) bool {
	// For now, let's say CMake can resolve dependencies if the other language is Go,
	// assuming CGo might be involved, or if it's another C++ rule generator.
	// This is a placeholder; real cross-resolution logic is more involved.
	// log.Printf("CanCrossResolve: Checking if cmake can cross-resolve with %s", other.Name())
	// return other.Name() == "go" || other.Name() == "cc" // Example
	return false // Keep it simple for now.
}

// Fix is called to fix issues in existing rules.
func (l *cmakeLang) Fix(c *config.Config, f *rule.File) {
	// For now, this is a no-op
	// In a real implementation, this might fix deprecated attributes or syntax
}

// Imports returns a list of imports for the given rule.
func (l *cmakeLang) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	// For now, return empty list
	// In a real implementation, this would parse source files for #include statements
	return nil
}

// matchesConfigureFileOutput checks if a header file matches a configure_file output.
// It handles CMake variable substitution (e.g., ${GENERATED_DIR}) and basename matching.
func matchesConfigureFileOutput(header, configOutput string) bool {
	// Direct match
	if header == configOutput {
		return true
	}

	// Check against .cmake-build/ prefix (existing logic)
	if header == ".cmake-build/"+filepath.Base(configOutput) {
		return true
	}

	// Extract basename from configure_file output, handling CMake variables
	configBasename := filepath.Base(configOutput)
	// Remove common CMake variable patterns from the path
	configClean := strings.ReplaceAll(configOutput, "${GENERATED_DIR}/", "")
	configClean = strings.ReplaceAll(configClean, "${CMAKE_CURRENT_BINARY_DIR}/", "")
	configClean = strings.ReplaceAll(configClean, "${CMAKE_BINARY_DIR}/", "")
	
	// Check if header matches the cleaned path or just the basename
	if header == configClean || header == filepath.Base(configClean) {
		return true
	}

	// Check if just the basenames match
	if filepath.Base(header) == configBasename {
		return true
	}

	return false
}

// discoverConfigureFileHeaders checks if configure_file outputs would be accessible via target include directories.
// For generated headers, we check if the output directory is included in the target's include paths.
func discoverConfigureFileHeaders(cmakeTargets []*common.CMakeTarget, configureFiles []*common.CMakeConfigureFile, sourceDir string) {
	if len(configureFiles) == 0 {
		return
	}

	log.Printf("Discovering headers for %d configure_file outputs", len(configureFiles))

	// For each configure_file, check if its output directory is accessible via include paths
	for _, configFile := range configureFiles {
		configBasename := filepath.Base(configFile.OutputFile)
		configDir := getConfigureFileOutputDirectory(configFile.OutputFile, sourceDir)
		log.Printf("Looking for targets that include directory for configure_file output: %s (basename: %s, dir: %s)", configFile.OutputFile, configBasename, configDir)
		
		// Check each target to see if it includes the directory where the configure_file output will be generated
		for _, target := range cmakeTargets {
			if targetIncludesDirectory(target, configDir, sourceDir) {
				log.Printf("Target %s includes directory %s, adding header %s", target.Name, configDir, configBasename)
				target.Headers = appendIfMissing(target.Headers, configBasename)
			}
		}
	}
}

// getConfigureFileOutputDirectory extracts the directory where a configure_file output will be generated.
func getConfigureFileOutputDirectory(outputFile, sourceDir string) string {
	// Handle CMake variable substitution
	outputClean := outputFile
	outputClean = strings.ReplaceAll(outputClean, "${GENERATED_DIR}", ".cmake-build/generated")
	outputClean = strings.ReplaceAll(outputClean, "${CMAKE_CURRENT_BINARY_DIR}", ".cmake-build")
	outputClean = strings.ReplaceAll(outputClean, "${CMAKE_BINARY_DIR}", ".cmake-build")
	
	// Get the directory part
	return filepath.Dir(outputClean)
}

// targetIncludesDirectory checks if a target's include directories contain the specified directory.
func targetIncludesDirectory(target *common.CMakeTarget, targetDir, sourceDir string) bool {
	for _, includeDir := range target.IncludeDirectories {
		// Normalize include directory path
		normalizedIncludeDir := includeDir
		if !filepath.IsAbs(includeDir) {
			normalizedIncludeDir = filepath.Clean(includeDir)
		}
		
		// Check if the target directory matches or is accessible from the include directory
		if normalizedIncludeDir == targetDir || 
		   targetDir == "." || 
		   strings.HasPrefix(targetDir, normalizedIncludeDir+"/") ||
		   strings.HasPrefix(normalizedIncludeDir, targetDir+"/") || // Include subdirectory can access parent
		   (normalizedIncludeDir == ".cmake-build/generated/dummy" && targetDir == ".cmake-build/generated") {
			log.Printf("Target %s include directory %s matches configure_file directory %s", target.Name, normalizedIncludeDir, targetDir)
			return true
		}
	}
	return false
}

