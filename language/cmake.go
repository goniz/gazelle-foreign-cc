package language

import (
	"flag"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/language"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
	"github.com/goniz/gazelle-foreign-cc/gazelle"
)

// cmakeLang implements the language.Language interface for CMake.
type cmakeLang struct{}

// NewLanguage returns a new instance of the CMake language plugin.
func NewLanguage() language.Language {
	return &cmakeLang{}
}

// Name returns the name of the language. This should be a prefix
// of the kinds of rules generated by the language, e.g., "go" for
// "go_library".
func (l *cmakeLang) Name() string {
	return "cmake"
}

// Embeds returns a list of labels that this rule embeds.
func (l *cmakeLang) Embeds(r *rule.Rule, from label.Label) []label.Label {
	return nil
}

// RegisterFlags registers command-line flags used by the language.
// The syntax of options passed to Gazelle is determined by package flag.
// All flags registered here become directives in BUILD files.
func (l *cmakeLang) RegisterFlags(fs *flag.FlagSet, mode string, c *config.Config) {
	// No flags registered for now.
}

// CheckFlags validates command-line flags and items in config files.
// Call fs.Visit to already-parsed flags.
func (l *cmakeLang) CheckFlags(fs *flag.FlagSet, c *config.Config) error {
	// No flags to check for now.
	return nil
}

// KnownDirectives returns a list of directive keys that this language
// understands. Gazelle will warn about directives that are not recognized.
func (l *cmakeLang) KnownDirectives() []string {
	// Combine directives known by the language itself and by the configurer.
	// This helps Gazelle recognize all valid directives.
	baseDirectives := []string{"gazelle:prefix"}                   // Directives handled by Gazelle itself or the language directly
	configDirectives := gazelle.NewCMakeConfig().KnownDirectives() // Directives handled by CMakeConfig
	return append(baseDirectives, configDirectives...)
}

// Configure modifies the configuration using directives found in BUILD files.
// Called with directives in root and package directories.
func (l *cmakeLang) Configure(c *config.Config, rel string, f *rule.File) {
	if f == nil {
		return // Not a BUILD file, skip.
	}

	cfg := gazelle.GetCMakeConfig(c)

	// Let the CMakeConfig handle its own directives
	cfg.Configure(c, rel, f)

	// Iterate over directives in the BUILD file for language-specific handling
	for _, directive := range f.Directives {
		// Check if the directive is one that the language itself handles directly
		// (as opposed to general configuration handled by CMakeConfig.Configure)
		switch directive.Key {
		// Example: Handle a language-specific directive if any
		// case "cmake_custom_lang_setting":
		//    log.Printf("cmakeLang.Configure: Found directive %s = %s", directive.Key, directive.Value)
		//    // Update language-specific state if necessary
		default:
			// If not handled by the language directly, it might be a general config
			// directive already processed by CMakeConfig.Configure.
		}
	}

	log.Printf("language.Configure: CMake executable is configured to: %s (in directory %s)", cfg.CMakeExecutable, rel)
}

// Kinds returns a map of Bazel rule kinds supported by this language.
func (l *cmakeLang) Kinds() map[string]rule.KindInfo {
	return map[string]rule.KindInfo{
		"cc_library": {
			NonEmptyAttrs:  map[string]bool{"srcs": true, "hdrs": true},
			MergeableAttrs: map[string]bool{"srcs": true, "hdrs": true, "deps": true},
			ResolveAttrs:   map[string]bool{"deps": true},
		},
		"cc_binary": {
			NonEmptyAttrs:  map[string]bool{"srcs": true},
			MergeableAttrs: map[string]bool{"srcs": true, "deps": true},
			ResolveAttrs:   map[string]bool{"deps": true},
		},
		"cc_test": {
			NonEmptyAttrs:  map[string]bool{"srcs": true},
			MergeableAttrs: map[string]bool{"srcs": true, "deps": true},
			ResolveAttrs:   map[string]bool{"deps": true},
		},
	}
}

// Loads returns .bzl files and symbols they define.
func (l *cmakeLang) Loads() []rule.LoadInfo {
	return []rule.LoadInfo{
		{
			Name:    "@rules_cc//cc:defs.bzl",
			Symbols: []string{"cc_library", "cc_binary", "cc_test"},
		},
	}
}

// GenerateRules extracts build metadata from source files in a directory.
// GenerateRules is called in each directory where an update is requested
// in resolve or generate mode.
func (l *cmakeLang) GenerateRules(args language.GenerateArgs) language.GenerateResult {
	cfg := gazelle.GetCMakeConfig(args.Config)

	// Check for cmake or cmake_source directive in the current BUILD file
	var cmakeSource string
	var isSourceDirective bool
	if args.File != nil {
		for _, directive := range args.File.Directives {
			if directive.Key == "cmake" {
				cmakeSource = directive.Value
				isSourceDirective = false
				log.Printf("Found cmake directive: %s in package %s", cmakeSource, args.Rel)
				break
			} else if directive.Key == "cmake_source" {
				cmakeSource = directive.Value
				isSourceDirective = true
				log.Printf("Found cmake_source directive: %s in package %s", cmakeSource, args.Rel)
				break
			}
		}
	}

	// If we have a cmake or cmake_source directive pointing to external sources, process that
	if cmakeSource != "" {
		log.Printf("cmakeLang.GenerateRules: Processing cmake directive %s for package %s", cmakeSource, args.Rel)
		return l.generateRulesFromExternalSource(args, cmakeSource, isSourceDirective)
	}

	// Otherwise, look for local CMakeLists.txt
	cmakeFilePath := filepath.Join(args.Dir, "CMakeLists.txt")

	if _, err := os.Stat(cmakeFilePath); os.IsNotExist(err) {
		log.Printf("No CMakeLists.txt found in %s (%s). Skipping directory.", args.Rel, cmakeFilePath)
		return language.GenerateResult{}
	}

	log.Printf("cmakeLang.GenerateRules: Called for package %s", args.Rel)

	// Try to use CMake File API first
	buildDir := filepath.Join(args.Dir, ".cmake-build")
	api := NewCMakeFileAPI(args.Dir, buildDir, cfg.CMakeExecutable)

	cmakeTargets, err := api.GenerateFromAPI(args.Rel)
	if err != nil {
		log.Printf("CMake File API failed for %s: %v. Falling back to regex parsing.", args.Rel, err)
		// Fallback to regex-based parsing using the existing function from gazelle package
		return gazelle.GenerateRules(args)
	}

	return l.generateRulesFromTargets(args, cmakeTargets)
}

// generateRulesFromExternalSource handles the cmake directive pointing to external sources
func (l *cmakeLang) generateRulesFromExternalSource(args language.GenerateArgs, sourceLabel string, isSourceDirective bool) language.GenerateResult {
	log.Printf("generateRulesFromExternalSource: Processing external source %s (isSourceDirective: %v)", sourceLabel, isSourceDirective)

	var repoName string
	
	if !strings.HasPrefix(sourceLabel, "@") {
		log.Printf("Invalid external source label format: %s. Expected format: @repo or @repo//:target", sourceLabel)
		return language.GenerateResult{}
	}

	if isSourceDirective {
		// For cmake_source directive, expect simple format: @repo_name
		repoName = sourceLabel[1:] // Remove @ prefix
		if repoName == "" {
			log.Printf("Empty repository name in cmake_source directive: %s", sourceLabel)
			return language.GenerateResult{}
		}
		if strings.Contains(repoName, "/") {
			log.Printf("Invalid cmake_source format: %s. Expected simple format: @repo", sourceLabel)
			return language.GenerateResult{}
		}
	} else {
		// For cmake directive, expect format: @repo_name//:target_name or @repo_name//path:target_name
		parts := strings.Split(sourceLabel, "//")
		if len(parts) != 2 {
			log.Printf("Invalid cmake label format: %s. Expected format: @repo//path:target", sourceLabel)
			return language.GenerateResult{}
		}

		repoName = parts[0][1:] // Remove @ prefix

		// Validate repository name
		if repoName == "" {
			log.Printf("Empty repository name in cmake directive: %s", sourceLabel)
			return language.GenerateResult{}
		}
	}

	// For this implementation, we'll look for the external repository in common locations
	// This is a simplified approach - a full implementation would integrate with Bazel's
	// repository resolution system
	externalRepoPath := l.findExternalRepo(repoName, args)
	if externalRepoPath == "" {
		log.Printf("Could not find external repository %s for label %s", repoName, sourceLabel)
		return language.GenerateResult{}
	}

	log.Printf("Found external repository %s at %s", repoName, externalRepoPath)

	// Look for CMakeLists.txt in the external repository
	cmakeFilePath := filepath.Join(externalRepoPath, "CMakeLists.txt")
	if _, err := os.Stat(cmakeFilePath); os.IsNotExist(err) {
		log.Printf("No CMakeLists.txt found in external repository %s at %s", repoName, cmakeFilePath)
		return language.GenerateResult{}
	}

	log.Printf("Found CMakeLists.txt in external repository at: %s", cmakeFilePath)

	// Process the external CMake project
	cfg := gazelle.GetCMakeConfig(args.Config)
	buildDir := filepath.Join(externalRepoPath, ".cmake-build")
	api := NewCMakeFileAPI(externalRepoPath, buildDir, cfg.CMakeExecutable)

	cmakeTargets, err := api.GenerateFromAPI(args.Rel)
	if err != nil {
		log.Printf("CMake File API failed for external source %s: %v. Falling back to regex parsing.", sourceLabel, err)
		// Create a modified args for the external directory
		externalArgs := args
		externalArgs.Dir = externalRepoPath
		return gazelle.GenerateRules(externalArgs)
	}

	log.Printf("Successfully parsed %d CMake targets from external repository %s", len(cmakeTargets), repoName)
	return l.generateRulesFromTargets(args, cmakeTargets)
}

// findExternalRepo attempts to locate an external repository
func (l *cmakeLang) findExternalRepo(repoName string, args language.GenerateArgs) string {
	// Common locations where Bazel might place external repositories
	// We need to be more sophisticated about this in a real implementation
	possiblePaths := []string{
		// Bazel output base external directory
		filepath.Join(args.Config.RepoRoot, "bazel-"+filepath.Base(args.Config.RepoRoot), "external", repoName),
		// Bazel execroot external directory
		filepath.Join(args.Config.RepoRoot, "bazel-out", "external", repoName),
		// Module cache for bzlmod (newer Bazel versions)
		filepath.Join(args.Config.RepoRoot, "bazel-"+filepath.Base(args.Config.RepoRoot), "external", "_main~"+repoName),
		// Additional bzlmod patterns
		filepath.Join(args.Config.RepoRoot, "bazel-"+filepath.Base(args.Config.RepoRoot), "external", "bzlmod~"+repoName),
		// Local repository pattern for testing
		filepath.Join(args.Config.RepoRoot, repoName),
	}

	log.Printf("Searching for external repository '%s' in %d possible locations", repoName, len(possiblePaths))

	for i, path := range possiblePaths {
		log.Printf("  [%d] Checking: %s", i+1, path)
		if stat, err := os.Stat(path); err == nil && stat.IsDir() {
			log.Printf("  Found external repository at: %s", path)
			return path
		}
	}

	// Additional search in bazel output base for bzlmod repositories
	// This is a more comprehensive approach for finding bzlmod repos
	log.Printf("Attempting comprehensive search for repository '%s'", repoName)
	outputBase := strings.TrimSpace(os.Getenv("BAZEL_OUTPUT_BASE"))
	log.Printf("BAZEL_OUTPUT_BASE environment variable: '%s'", outputBase)
	if outputBase == "" {
		// Try to get output base from bazel info (fallback)
		log.Printf("Trying to get output base from bazel info command")
		cmd := exec.Command("bazel", "info", "output_base")
		cmd.Dir = args.Config.RepoRoot
		if output, err := cmd.Output(); err == nil {
			outputBase = strings.TrimSpace(string(output))
			log.Printf("Got output base from bazel info: '%s'", outputBase)
		} else {
			log.Printf("Failed to get output base from bazel info: %v", err)
		}
	}
	
	if outputBase != "" {
		// Search for bzlmod repository patterns in the actual bazel output base
		externalDir := filepath.Join(outputBase, "external")
		log.Printf("Searching in external directory: %s", externalDir)
		if entries, err := os.ReadDir(externalDir); err == nil {
			log.Printf("Found %d entries in external directory", len(entries))
			for _, entry := range entries {
				if entry.IsDir() {
					entryName := entry.Name()
					log.Printf("  Checking entry: %s (contains '%s'? %v)", entryName, repoName, strings.Contains(entryName, repoName))
					// Check various patterns that might match our repository
					if strings.Contains(entryName, repoName) {
						candidate := filepath.Join(externalDir, entryName)
						log.Printf("  Found potential bzlmod repository at: %s", candidate)
						return candidate
					}
				}
			}
			log.Printf("No matching repositories found in external directory")
		} else {
			log.Printf("Failed to read external directory %s: %v", externalDir, err)
		}
	} else {
		log.Printf("No output base available for comprehensive search")
	}

	log.Printf("Could not find external repository '%s' in any standard location", repoName)
	return ""
}

// generateRulesFromTargets converts CMakeTarget objects to Bazel rules
func (l *cmakeLang) generateRulesFromTargets(args language.GenerateArgs, cmakeTargets []*gazelle.CMakeTarget) language.GenerateResult {
	res := language.GenerateResult{}

	for _, cmTarget := range cmakeTargets {
		var r *rule.Rule
		if cmTarget.Type == "library" {
			r = rule.NewRule("cc_library", cmTarget.Name)
		} else if cmTarget.Type == "executable" {
			r = rule.NewRule("cc_binary", cmTarget.Name)
		} else {
			log.Printf("Unknown target type for %s: %s", cmTarget.Name, cmTarget.Type)
			continue
		}

		// Filter sources/headers against files actually in this directory
		var finalSrcs, finalHdrs []string
		for _, s := range cmTarget.Sources {
			if l.fileExistsInDir(s, args.Dir) {
				finalSrcs = append(finalSrcs, s)
			} else {
				log.Printf("Source file %s for target %s not found in current directory, skipping.", s, cmTarget.Name)
			}
		}
		for _, h := range cmTarget.Headers {
			if l.fileExistsInDir(h, args.Dir) {
				finalHdrs = append(finalHdrs, h)
			} else {
				log.Printf("Header file %s for target %s not found in current directory, skipping.", h, cmTarget.Name)
			}
		}

		if len(finalSrcs) > 0 {
			r.SetAttr("srcs", finalSrcs)
		}
		if len(finalHdrs) > 0 {
			r.SetAttr("hdrs", finalHdrs)
		}

		// Handle include directories
		if len(cmTarget.IncludeDirectories) > 0 {
			var includes []string
			for _, dir := range cmTarget.IncludeDirectories {
				// Only include relative paths that don't go outside the project
				if !filepath.IsAbs(dir) && !strings.HasPrefix(dir, "..") {
					includes = append(includes, dir)
				}
			}
			if len(includes) > 0 {
				r.SetAttr("includes", includes)
			}
		}

		// Store linked libraries for dependency resolution
		if len(cmTarget.LinkedLibraries) > 0 {
			r.SetPrivateAttr("cmake_linked_libraries", cmTarget.LinkedLibraries)
		}
		if len(cmTarget.IncludeDirectories) > 0 {
			r.SetPrivateAttr("cmake_include_directories", cmTarget.IncludeDirectories)
		}

		if r.Attr("srcs") != nil || r.Attr("hdrs") != nil {
			res.Gen = append(res.Gen, r)
			res.Empty = append(res.Empty, rule.NewRule(r.Kind(), r.Name()))
			log.Printf("Generated %s %s in %s with srcs: %v, hdrs: %v, includes: %v, links: %v",
				r.Kind(), r.Name(), args.Rel, finalSrcs, finalHdrs, cmTarget.IncludeDirectories, cmTarget.LinkedLibraries)
		} else {
			log.Printf("Skipping rule for target %s as no valid sources/headers were found in the current directory.", cmTarget.Name)
		}
	}

	if len(res.Gen) > 0 && len(res.Imports) == 0 {
		res.Imports = make([]interface{}, len(res.Gen))
	}

	return res
}

// fileExistsInDir checks if a file exists in the given directory
func (l *cmakeLang) fileExistsInDir(filename, dir string) bool {
	fullPath := filepath.Join(dir, filename)
	_, err := os.Stat(fullPath)
	return err == nil
}

// UpdateRules is called to update existing rules in a BUILD file.
// args.Rel is the package name. args.File is the existing BUILD file.
// This function can be used to modify or delete existing rules that
// this language extension manages.
func (l *cmakeLang) UpdateRules(args language.GenerateArgs) language.GenerateResult {
	log.Printf("cmakeLang.UpdateRules: Called for package %s", args.Rel)
	cfg := gazelle.GetCMakeConfig(args.Config)
	_ = cfg // Use cfg if needed for update logic based on configuration

	// In a more sophisticated plugin, you might iterate over args.File.Rules
	// to find rules previously generated by this plugin and update or delete them
	// based on changes in the source or CMakeLists.txt.

	// For now, we return an empty result, meaning Gazelle will rely on the rules
	// returned by GenerateRules (and its "Empty" rules for pruning) to determine
	// the final state of the BUILD file.
	return language.GenerateResult{}
}

// Resolve resolves dependencies for rules in the given BUILD file.
// This is called in resolve mode after GenerateRules and UpdateRules have run.
// 'r' is the rule to resolve. 'imports' is a list of imported strings.
// 'from' is the label of the rule 'r'.
func (l *cmakeLang) Resolve(c *config.Config, ix *resolve.RuleIndex, rc *repo.RemoteCache, r *rule.Rule, imports interface{}, from label.Label) {
	// Delegate to the ResolveDeps function in the gazelle package.
	// The 'imports' interface{} parameter in language.Resolver is what GenerateRules
	// returns in GenerateResult.Imports. Our current GenerateRules returns nil for Imports.
	// A more complete GenerateRules would parse source files for #include statements
	// and return them as []string in GenerateResult.Imports.
	if r.Kind() != "cc_library" && r.Kind() != "cc_binary" && r.Kind() != "cc_test" {
		return // We only resolve for our own rule kinds.
	}
	log.Printf("cmakeLang.Resolve: Called for rule %s %s, imports type: %T", r.Kind(), r.Name(), imports)
	// For now, this is a no-op - this is a basic stub
	// In a real implementation, this would resolve dependencies based on #include statements
}

// CanCrossResolve indicates whether this language can resolve dependencies
// in rules of another language. For example, if a Go rule depends on a C++ library.
func (l *cmakeLang) CanCrossResolve(other language.Language) bool {
	// For now, let's say CMake can resolve dependencies if the other language is Go,
	// assuming CGo might be involved, or if it's another C++ rule generator.
	// This is a placeholder; real cross-resolution logic is more involved.
	// log.Printf("CanCrossResolve: Checking if cmake can cross-resolve with %s", other.Name())
	// return other.Name() == "go" || other.Name() == "cc" // Example
	return false // Keep it simple for now.
}

// Fix is called to fix issues in existing rules.
func (l *cmakeLang) Fix(c *config.Config, f *rule.File) {
	// For now, this is a no-op
	// In a real implementation, this might fix deprecated attributes or syntax
}

// Imports returns a list of imports for the given rule.
func (l *cmakeLang) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	// For now, return empty list
	// In a real implementation, this would parse source files for #include statements
	return nil
}
